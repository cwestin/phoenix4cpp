/* Copyright (c) 2011 Chris Westin.  All Rights Reserved. */
/*
  NAME
    HashValue - see ../include/HashValue.h

  SOURCE
    phoenix4cpp - https://github.com/cwestin/phoenix4cpp

  LICENSE
    See ../LICENSE.txt.

  IMPLEMENTATION
 */

#ifndef PHOENIX4CPP_HASHVALUE_H
#include "HashValue.h"
#endif


namespace phoenix4cpp
{
    /*
      This method is private; we declare it first so that it can be inlined in
      this file.
     */
    inline void HashValue::rotate()
    {
	/* rotate left 5 bits */
	value = (value << 5) | (value >> 27);
    }

    void HashValue::blend(short v)
    {
	rotate();
	value ^= byteTable[v & 0xff];
	rotate();
	value ^= byteTable[(v >> 8) & 0xff];
    }

    void HashValue::blend(unsigned long v)
    {
	rotate();
	value ^= byteTable[v & 0xff];
	rotate();
	value ^= byteTable[(v >> 8) & 0xff];
	rotate();
	value ^= byteTable[(v >> 16) & 0xff];
	rotate();
	value ^= byteTable[(v >> 24) & 0xff];
    }

    void HashValue::blend(const char *pS)
    {
	for(; *pS; ++pS)
	{
	    rotate();
	    value ^= byteTable[(unsigned)*pS];
	}
    }

    /*
      Lookup table -- this was generated by the main() at the bottom of this
      file.
     */
    const unsigned long HashValue::byteTable[256] = 
    {
	0x99af75dd,
	0x74a73b0b,
	0x87552784,
	0xbf854309,
	0xcb92be53,
	0x7735e65a,
	0xe876cdb7,
	0x11ebe423,
	0xefc0ff57,
	0x66f614c5,
	0x80b294b8,
	0xb647f6c2,
	0x0e3f6751,
	0x7170cf98,
	0x889dca64,
	0x3ce96be1,
	0x1de2b3e3,
	0x3da27b01,
	0xa8d9c88b,
	0x8c3af751,
	0xa2486605,
	0xfd2ee4cd,
	0x896a779c,
	0x3961cce7,
	0xe543d710,
	0xf2dc3555,
	0x08971ced,
	0x926ce6dd,
	0xe8746e24,
	0x885db41b,
	0x968cc203,
	0x49615cde,
	0x771c938f,
	0x614d3009,
	0x499c241b,
	0x264e0d8c,
	0x25440490,
	0x37d1e276,
	0xc2ee6079,
	0xc1ea31be,
	0xf56225f2,
	0x9f9b269d,
	0x1391272b,
	0x0854e28a,
	0x8072b1c9,
	0xccfe188e,
	0x2eb7297c,
	0x521f33f7,
	0x072fb3d5,
	0x5962fd5c,
	0x3eac5bd4,
	0xd0adc572,
	0xc9d5db69,
	0x8dd663da,
	0xab78b34c,
	0x4e5cb4a9,
	0xdc2598f8,
	0xf4e913c6,
	0xd31536da,
	0x8aa35af6,
	0x22cfd205,
	0xb2ad98f1,
	0x47cbeaf3,
	0x07f33816,
	0x9f2cba96,
	0x822f35c4,
	0x718924ae,
	0xf5b6ce6e,
	0xfac11074,
	0x62a5fb59,
	0x68fbfdf1,
	0x7d855f8d,
	0x10d1c9bb,
	0x863002ed,
	0x31b57d56,
	0x25186f0f,
	0x8e376d18,
	0x94af5c3f,
	0x52ee2c7e,
	0x57e2f767,
	0x91dc695f,
	0x8171fea8,
	0x5e9b28ab,
	0x46d9f802,
	0xdbe8fbeb,
	0x8a42aa9e,
	0x321c6db0,
	0xcb7113cf,
	0x835a8a95,
	0xd6a5e011,
	0x6d86e7bc,
	0x39c00142,
	0x9578d914,
	0x5f063133,
	0x54c2fbec,
	0x7f64817c,
	0x96ef143c,
	0x474aec89,
	0xbb0bd8f4,
	0xbaafb57e,
	0x450339a1,
	0xf4e5635e,
	0x5e4a5d5b,
	0x7a651bd2,
	0x2f5f0466,
	0x38ae8883,
	0x306923f2,
	0xc7010aa4,
	0xd00e10fa,
	0x87a6c59a,
	0x4e941a0d,
	0x244d82d5,
	0x2dda20fd,
	0xb497fc19,
	0xa6645d0a,
	0x9e4f7aab,
	0x704e3a3b,
	0xea3cc445,
	0x79c8f5d7,
	0x91ed3d4a,
	0xe965b933,
	0x2d991658,
	0x138e63fa,
	0x48996a43,
	0xdee0156e,
	0xb789b1fe,
	0x4f32588d,
	0xcf8c2951,
	0xa9f0f1b7,
	0x8baf43a4,
	0x6f957d2c,
	0x931fc60d,
	0x93b1c1ae,
	0x360cedf7,
	0xb057d86b,
	0xb3a14278,
	0x0bbed24d,
	0x4b7e0cd6,
	0x6be12207,
	0xc44ca87c,
	0xd0363bdb,
	0xb246506c,
	0xa7037288,
	0xb23b5817,
	0xd7aa1ece,
	0x7a3e52ef,
	0x0629d27a,
	0x1d5e1892,
	0xde3d32f0,
	0x15eba939,
	0x6f2640be,
	0x1153f3c0,
	0xb8cc8b85,
	0xddca80e0,
	0x34ff4afa,
	0x73ba4522,
	0x752b0f6d,
	0xd886361a,
	0x87e46cdf,
	0x00a62b37,
	0x66dbc779,
	0x40079c3f,
	0xc43c90bd,
	0x4d732e5b,
	0x3aa15668,
	0xa56e1635,
	0x810fd3c0,
	0xb51a0e4b,
	0x0082b40c,
	0xbca211f5,
	0x546526fc,
	0xe821f8a4,
	0x76a6a1dc,
	0x3473ba83,
	0x9753a049,
	0x2169d7a5,
	0xbcb83205,
	0x9219ec9f,
	0xfc578e5d,
	0xf25a55c3,
	0x60a42a9a,
	0x1720820a,
	0xa0e341d9,
	0x20f92f1d,
	0xa0d10cc6,
	0x93410858,
	0xe5cdcb2a,
	0xde566b63,
	0xe57b1f1b,
	0x7081848f,
	0x019b0d2b,
	0x19a74f40,
	0x08e7621e,
	0x75c36012,
	0x349537ea,
	0x90687fcc,
	0x3db03867,
	0xae53cabd,
	0x761d0a79,
	0x1cd06041,
	0xc84ce72a,
	0xd3ac2df8,
	0xac739121,
	0xb5238d7b,
	0x09124475,
	0xaa285019,
	0x1f976a84,
	0x4b4405ac,
	0xc32304e0,
	0x59e34487,
	0xc9270b9d,
	0x0e2e1a6c,
	0x282a1e12,
	0xd477aa49,
	0x17abddf1,
	0xc8220627,
	0x174c3846,
	0x6f615b9f,
	0x006421c5,
	0xe154ad8f,
	0xdfb89834,
	0xf97bffd6,
	0x509c6731,
	0x56c34f20,
	0x3ed10fcd,
	0xeee6bb8b,
	0xe6ec8fc7,
	0x6a597f47,
	0x4851ca9b,
	0x7ed44504,
	0x2cb9bdbb,
	0xbf402816,
	0x9aefc774,
	0x15ce68c1,
	0x96f602a0,
	0xebfef03e,
	0x7ca878b6,
	0x291eb6bf,
	0x504b9ee4,
	0xffe10370,
	0xc6d40084,
	0xb994427d,
	0xf4dae33a,
	0x860955ad,
	0xa372df33,
	0xe94652f3,
	0x80dff9d8,
	0x3041eeb0,
	0x9db9a990,
	0x65fc9ed3,
	0xd5a3bf9a,
	0x7f06482d,
	0x3f1402a7,
	0xf085cea2,
	0x12b1bc83,
	0xf999bda3,
    };

}

#if 0
/*
  This program generates a table of 256 randomly generated unsigned longs.

  The intention is to use this for hashing, so we want a randomly distributed
  set of bits.
 */
#include <stdio.h>
#include <stdlib.h>

int main()
{
    /*
      We declare a union of the resulting array of longs (ul) and an array of
      bytes (uc) that we can use to manipulate the values.
     */
    union
    {
	unsigned long ul[256];
	unsigned char uc[1024];
    } a;

    /*
      Initialize the array.

      In order to guarantee that the number of ones and zeroes is fair, we use
      every possible byte-sized bit pattern an equal number of times.  Each
      long is initialized with 4 copies of the same bit pattern; all the bit
      patterns for an 8 bit number are used.
    */
    for(int i = 0; i < 256; ++i)
    {
	a.uc[i*4 + 0] = i;
	a.uc[i*4 + 1] = i;
	a.uc[i*4 + 2] = i;
	a.uc[i*4 + 3] = i;
    }

    /*
      Scramble the array.

      We use a pseudo-random number to generate two indices and then swap
      the chosen elements of the byte array.  Repeat this a very large number of
      times.
    */
    srandom(0x20380119);
    for(int i = 0; i < 10000000; ++i)
    {
	int j = random() % 1024;
	int k = random() % 1024;

	/* swap the values */
	int temp = a.uc[j];
	a.uc[j] = a.uc[k];
	a.uc[k] = temp;
    }

    /*
      Print the array.

      A format is chosen that is usable for initializing a lookup table.
    */
    for(int i = 0; i < 256; ++i)
    {
	printf("    0x%08lx,\n", a.ul[i]);
    }

    return 0;
}
#endif
